:github-address: https://github.com/hazelcast-guides/kubernetes-external-client
:templates-url: templates:ROOT:page$/
:hazelcast: Hazelcast IMDG
:framework: Kubernetes

= Connect To Hazelcast Running on Kubernetes from Outside

This is a complete example presenting how to use Hazelcast cluster deployed on Kubernetes with Hazelcast Client running outside of Kubernetes.

include::{templates-url}/link-to-repo.adoc[]

== What You’ll Learn

In this guide you will learn how to deploy Hazelcast Kubernetes cluster and connect to it using a client outside Kubernetes.

== Prerequisites

* Up and running https://kubernetes.io/[Kubernetes] cluster (https://minikube.sigs.k8s.io/docs/[Minikube] is good enough)
* Kubernetes command line tool, https://kubernetes.io/docs/tasks/tools/install-kubectl/[kubectl]

== Configure Hazelcast cluster on Kubernetes

There are two approaches you may want to use when setting up on-premises Hazelcast cluster in Kubernetes:
* **Unisocket Client** - client sends requests to a random Hazelcast member
* **Smart Client** - client connects to all members and sends requests directly to the right members

Let's see both approaches.

=== Unisocket Client

The simplest possible scenario is to deploy the Hazelcast cluster on Kubernetes and expose all Hazelcast pods with one `LoadBalancer` (or `NodePort`) service. With that approach, we piggyback on the standard Kubernetes mechanism, which automatically load balances the traffic to Hazelcast members.

.Hazelcast Unisocket Client
image::unisocket.jpg[Hazelcast Unisocket Client]

==== Starting Hazelcast cluster

There are different ways of deploying Hazelcast to Kubernetes. For the production environment we recommend using Helm.

[tabs]
====

Kubectl::
+

--
[source, bash]
----
kubectl apply -f https://raw.githubusercontent.com/hazelcast/hazelcast-kubernetes/master/rbac.yaml

kubectl run hz-hazelcast-0 --image=hazelcast/hazelcast:$HAZELCAST_VERSION -l "role=hazelcast"
kubectl run hz-hazelcast-1 --image=hazelcast/hazelcast:$HAZELCAST_VERSION -l "role=hazelcast"
kubectl run hz-hazelcast-2 --image=hazelcast/hazelcast:$HAZELCAST_VERSION -l "role=hazelcast"

kubectl create service loadbalancer hz-hazelcast --tcp=5701 -o yaml --dry-run=client | kubectl set selector --local -f - "role=hazelcast" -o yaml | kubectl create -f -
----
--

Helm::
+
--
[source, bash]
----
helm repo add hazelcast https://hazelcast-charts.s3.amazonaws.com/
helm repo update
helm install hz-hazelcast --set service.type=LoadBalancer hazelcast/hazelcast
----
=====

==== Verifying Hazelcast cluster

You can check that the Hazelcast cluster is up and running.

[source, bash]
----
kubectl get pods
NAME             READY   STATUS    RESTARTS   AGE
hz-hazelcast-0   1/1     Running   0          32s
hz-hazelcast-1   1/1     Running   0          30s
hz-hazelcast-2   1/1     Running   0          29s
----

You can also check that all Hazelcast members formed one cluster.

[source, bash]
----
kubectl logs hz-hazelcast-0
...
Members {size:3, ver:3} [
        Member [10.216.6.7]:5701 - 6d2100e0-8dcf-4e7c-ab40-8e98e23475e3 this
        Member [10.216.5.6]:5701 - 5ab4d554-fd7d-4929-8475-0ddf79a21076
        Member [10.216.8.6]:5701 - 7f7dd5f4-e732-4575-89d6-a6e823da38da
]
----

At this point you have a Hazelcast cluster exposed with a single LoadBalancer service called `hz-hazelcast`. You can find it's address with the following command.

[source, bash]
----
kubectl get service hz-hazelcast
NAME           TYPE           CLUSTER-IP       EXTERNAL-IP       PORT(S)          AGE
hz-hazelcast   LoadBalancer   10.108.141.178   10.96.184.178     5701:31434/TCP   5m44s
----

[NOTE]
====
If you are using Minikube, you need to execute minikube tunnel now in order to get LoadBalancer External IPs assigned.
====

The field `EXERNAL-IP` is the address of your Hazelcast cluster.

=== Connecting with Hazelcast Client

Configure the Hazelcast client to connect to the cluster external address and disable smart routing (use unisocket connection).

[tabs]
====

Java::
+
--
[source, java]
----
ClientConfig config = new ClientConfig();
config.getNetworkConfig().addAddress("<EXTERNAL-IP>")
                         .setSmartRouting(false);
----
--

NodeJS::
+
--
[source, javascript]
----
const { Client } = require('hazelcast-client');

const clientConfig = {
    network: {
        clusterMembers: [
            'hz-hazelcast'
        ]
    }
};
const client = await Client.newHazelcastClient(clientConfig);
----
--
====

Finally, start the client application using the following command.

[tabs]
====

Java::
+
[source, shell script]
----
mvn -f java-unisocket/pom.xml package
java -jar java-unisocket/target/*jar-with-dependencies*.jar
----
--

NodeJS::
+
--
[source, javascript]
----
const { Client } = require('hazelcast-client');

const clientConfig = {
    network: {
        clusterMembers: [
            'hz-hazelcast'
        ]
    }
};
const client = await Client.newHazelcastClient(clientConfig);
----
--
====

=== Clean Up

To clean up the environment execute the following commands.

[tabs]
====

Kubectl::
+

--
[source, bash]
----
kubectl delete pod/hz-hazelcast-0 pod/hz-hazelcast-1 pod/hz-hazelcast-2 service/hz-hazelcast
kubectl delete -f https://raw.githubusercontent.com/hazelcast/hazelcast-kubernetes/master/rbac.yaml
----
--

Helm::
+
--
[source, bash]
----
helm uninstall hz-hazelcast
----
=====


Unisocket is very simple to configure; however, it has one significant drawback—low performance. Using a load balancer is perfect for traffic distribution across stateless services; however, Hazelcast is not stateless. Actually, Hazelcast is more like a sharded database in which each member contains a different part of the data. That is why it’s suboptimal to randomly load balance the traffic. It effectively means that each operation needs to be internally migrated, because your data may be load balanced to member 1, while the partition for its key is stored in member 2. All in all, if performance is important for your use case, then you need to use smart client.

== Smart Client

Hazelcast smart client stores the mapping from key to member, which means that it sends the data directly to the member which contains the right data partition. This fact implies that in the Kubernetes environment, we need to provide access to each Hazelcast pod from the outside. A dynamic approach to this problem is to expose each pod with a separate service. Again, the service can be either `LoadBalancer` or `NodePort`. In a real-life scenario, that would probably be `NodePort`, since having a separate public IP for each pod is expensive.

.Hazelcast Smart Client
image::smart.jpg[Hazelcast Smart Client]

Kubernetes does not offer a feature for automatically creating a service for each pod. That is why to set up a cluster this way we need to either expose each pod manually with `kubectl` or use the project called Metacontroller, which enables such functionality.

[tabs]
====
Kubectl::
+
--

To create a `loadbalancer` for each running Hazelcast pod you need to run the following command:

[source, bash]
----
kubectl apply -f https://raw.githubusercontent.com/hazelcast/hazelcast-kubernetes/master/rbac.yaml

kubectl create service loadbalancer hz-hazelcast-0 --tcp=5701
kubectl run hz-hazelcast-0 --image=hazelcast/hazelcast:$HAZELCAST_VERSION --port=5701 -l "app=hz-hazelcast-0,role=hazelcast"
kubectl create service loadbalancer hz-hazelcast-1 --tcp=5701
kubectl run hz-hazelcast-1 --image=hazelcast/hazelcast:$HAZELCAST_VERSION --port=5701 -l "app=hz-hazelcast-1,role=hazelcast"
kubectl create service loadbalancer hz-hazelcast-2 --tcp=5701
kubectl run hz-hazelcast-2 --image=hazelcast/hazelcast:$HAZELCAST_VERSION --port=5701 -l "app=hz-hazelcast-2,role=hazelcast"

kubectl create service loadbalancer hz-hazelcast --tcp=5701 -o yaml --dry-run=client | kubectl set selector --local -f - "role=hazelcast" -o yaml | kubectl create -f -
----
--

Helm and Metacontroller::
+
--
- Install Metacontroller plugin

To install https://metacontroller.app/[Metacontroller] plugin, execute the following commands:

[source, shell script]
----
# Create metacontroller namespace.
kubectl create namespace metacontroller
# Create metacontroller service account and role/binding.
kubectl apply -f https://raw.githubusercontent.com/metacontroller/metacontroller/v1.4.2/manifests/production/metacontroller-rbac.yaml
# Create CRDs for Metacontroller APIs
kubectl apply -f https://raw.githubusercontent.com/metacontroller/metacontroller/v1.4.2/manifests/production/metacontroller-crds-v1.yaml
# Create Metacontroller StatefulSet.
kubectl apply -f https://raw.githubusercontent.com/metacontroller/metacontroller/v1.4.2/manifests/production/metacontroller.yaml
----

If you have any issues while creating Metacontroller, it may mean that you don't have ClusterRole access to your cluster. Please check https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control#defining_permissions_in_a_role[this] for details.

- Install Service-Per-Pod DecoratorController

To install Service-Per-Pod Decorator Controller, you need to execute the following commands.

[source, shell script]
----
kubectl create configmap service-per-pod-hooks -n metacontroller --from-file=hooks
kubectl apply -f service-per-pod.yaml
----

This Decorator Controller automatically creates a service for each POD marked with the specific annotations, so you can start Hazelcast cluster using the following Helm command.
[source, bash]
----
helm repo add hazelcast https://hazelcast-charts.s3.amazonaws.com/
helm repo update
helm install hz-hazelcast \
     --set service.type=LoadBalancer \
     --set annotations.service-per-pod-label=statefulset.kubernetes.io/pod-name,annotations.service-per-pod-ports="5701:5701" \
     hazelcast/hazelcast
----
--
====

[NOTE]
====
Note that each service created per pod must start before Hazelcast itself. Otherwise Hazelcast won't be able to resolve its public addresses.
====

==== Verifying Hazelcast cluster

You can check that the Hazelcast cluster is up and running.

[source, bash]
----
kubectl get pods
NAME             READY   STATUS    RESTARTS   AGE
hz-hazelcast-0   1/1     Running   0          32s
hz-hazelcast-1   1/1     Running   0          30s
hz-hazelcast-2   1/1     Running   0          29s
----

At this point, you should also have every Hazelcast member exposed with a separate externally accessible address.


[source, bash]
----
kubectl get service
NAME             TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)          AGE
hz-hazelcast     LoadBalancer   10.219.246.40    35.230.84.127    5701:30443/TCP   4m2s
hz-hazelcast-0   LoadBalancer   10.219.255.141   34.145.108.167   5701:30091/TCP   4m7s
hz-hazelcast-1   LoadBalancer   10.219.241.203   34.82.71.106     5701:30687/TCP   4m5s
hz-hazelcast-2   LoadBalancer   10.219.247.106   35.247.93.190    5701:32452/TCP   4m4s
----

We'll use the `hz-hazelcast` service for the discovery.

[source, bash]
----
kubectl get service hz-hazelcast
NAME           TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)          AGE
hz-hazelcast   LoadBalancer   10.219.246.40   35.230.84.127   5701:30443/TCP   5m29s
----

[NOTE]
====
If you are using Minikube, you need to execute minikube tunnel now in order to get LoadBalancer External IPs assigned.
====

The field `EXERNAL-IP` is the address of your Hazelcast cluster.

=== Connecting with Hazelcast Client

Configure the Hazelcast client to connect to the cluster external address.

[tabs]
====

Java::
+
--
[source, java]
----
ClientConfig config = new ClientConfig();
config.getNetworkConfig().addAddress("<EXTERNAL-IP>");
----
--

NodeJS::
+
--
[source, javascript]
----
const { Client } = require('hazelcast-client');

const clientConfig = {
    network: {
        clusterMembers: [
            'hz-hazelcast'
        ]
    }
};
const client = await Client.newHazelcastClient(clientConfig);
----
--
====

Finally, start the client application using the following command.

[tabs]
====

Java::
+
[source, shell script]
----
mvn -f java/pom.xml package
java -jar java/target/*jar-with-dependencies*.jar
----
--

NodeJS::
+
--
[source, javascript]
----
const { Client } = require('hazelcast-client');

const clientConfig = {
    network: {
        clusterMembers: [
            'hz-hazelcast'
        ]
    }
};
const client = await Client.newHazelcastClient(clientConfig);
----
--
====

=== Clean Up

To clean up the environment execute the following commands.

[tabs]
====

Kubectl::
+

--
[source, bash]
----
kubectl delete pod/hz-hazelcast-0 service/hz-hazelcast-0 pod/hz-hazelcast-1 service/hz-hazelcast-1 pod/hz-hazelcast-2 service/hz-hazelcast-2 service/hz-hazelcast
kubectl delete -f https://raw.githubusercontent.com/hazelcast/hazelcast-kubernetes/master/rbac.yaml
----
--

Helm and Metacontroller::
+
--
[source, bash]
----
helm uninstall hz-hazelcast

kubectl delete -f service-per-pod.yaml
kubectl delete configmap service-per-pod-hooks -n metacontroller

kubectl delete -f https://raw.githubusercontent.com/metacontroller/metacontroller/v1.4.2/manifests/production/metacontroller.yaml
kubectl delete -f https://raw.githubusercontent.com/metacontroller/metacontroller/v1.4.2/manifests/production/metacontroller-crds-v1.yaml
kubectl delete -f https://raw.githubusercontent.com/metacontroller/metacontroller/v1.4.2/manifests/production/metacontroller-rbac.yaml
kubectl delete namespace metacontroller
----
=====


[NOTE]
====
If you are using Minikube, you need to execute minikube tunnel now in order to get LoadBalancer External IPs assigned.
====

The field `EXERNAL-IP` is the address of your Hazelcast cluster.

[NOTE]
====
At this point you can already start using your Hazelcast cluster externally with the Unisocket Client (`smart-routing: false`), however it means lower performance. To achieve the best performance, use Smart Client as described below.
====

=== Expose each Hazelcast Member

To use Hazelcast Smart Client, every Hazelcast member needs to be accessible with a separate external address. In Kubernetes PODs can be accessed from outside only via services, so the configuration requires creating a separate service (LoadBalancer or NodePort) for each Hazelcast member POD. This can be done manually or using https://metacontroller.app/[Metacontroller] plugin with https://github.com/metacontroller/metacontroller/tree/master/examples/service-per-pod[Service-Per-Pod] Decorator Controller.

[tabs]
====
Manual::
+
--

To create a `loadbalancer` for each running Hazelcast pod you need to run the following command:

[source, shell script]
----
for pod in $(kubectl get pods --selector=role=hazelcast -o jsonpath="{.items[*].metadata.name}"); do \
  kubectl create service loadbalancer ${pod} --tcp=5701 -o yaml --dry-run=client | kubectl set selector --local -f - "name=${pod}" -o yaml | kubectl create -f -; \
done
----
--

Metacontroller::
+
--
- Install Metacontroller plugin

To install https://metacontroller.app/[Metacontroller] plugin, execute the following commands:

[source, shell script]
----
# Create metacontroller namespace.
kubectl create namespace metacontroller
# Create metacontroller service account and role/binding.
kubectl apply -f https://raw.githubusercontent.com/metacontroller/metacontroller/v1.4.2/manifests/production/metacontroller-rbac.yaml
# Create CRDs for Metacontroller APIs
kubectl apply -f https://raw.githubusercontent.com/metacontroller/metacontroller/v1.4.2/manifests/production/metacontroller-crds-v1.yaml
# Create Metacontroller StatefulSet.
kubectl apply -f https://raw.githubusercontent.com/metacontroller/metacontroller/v1.4.2/manifests/production/metacontroller.yaml
----

If you have any issues while creating Metacontroller, it may mean that you don't have ClusterRole access to your cluster. Please check https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control#defining_permissions_in_a_role[this] for details.

- Install Service-Per-Pod DecoratorController

To install Service-Per-Pod Decorator Controller, you need to execute the following commands.

[source, shell script]
----
kubectl create configmap service-per-pod-hooks -n metacontroller --from-file=hooks
kubectl apply -f service-per-pod.yaml
----

This Decorator Controller automatically creates a service for each POD marked with the following annotations, so you need to add these annotations to your running Hazelcast pods.
[source, yaml]
----
annotations:
    service-per-pod-label: "statefulset.kubernetes.io/pod-name"
    service-per-pod-ports: "5701:5701"
----
--
====

Check the services were created with by running the command:

[source, shell script]
----
$ kubectl get svc
NAME             TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)          AGE
hz-hazelcast     LoadBalancer   10.108.141.178   10.96.184.178   5701:30915/TCP   11m
hz-hazelcast-0   LoadBalancer   10.175.248.67    35.195.77.97    5701:30915/TCP   11m
hz-hazelcast-1   LoadBalancer   10.175.254.105   104.155.70.30   5701:30440/TCP   11m
hz-hazelcast-2   LoadBalancer   10.175.253.232   34.78.182.50    5701:30305/TCP   11m
----

== Configure Hazelcast Client outside Kubernetes

When we have a working Hazelcast cluster deployed on Kubernetes, we can connect to it with an external Hazelcast Smart Client.

To use Hazelcast client, add Hazelcast client dependency to your application.

[tabs]
====

Java::
+
--
.pom.xml
[source, xml]
----
<dependency>
    <groupId>com.hazelcast</groupId>
    <artifactId>hazelcast</artifactId>
    <version>${hazelcast.version}</version>
</dependency>
----
--

NodeJS::
+
--
[source, bash]
----
npm install hazelcast-client
----
--
====

Check again the EXTERNAL-IP (or `NODE-IP:NODE_PORT` in case of using NodePort services) of your LoadBalancer service.

[source, bash]
----
kubectl get service hz-hazelcast
NAME           TYPE           CLUSTER-IP       EXTERNAL-IP       PORT(S)          AGE
hz-hazelcast   LoadBalancer   10.108.141.178   10.96.184.178     5701:31434/TCP   5m44s
----

Configure the Hazelcast client in your application to connect to the your cluster using `EXTERNAL-IP` (or `NODE-IP:NODE_PORT` in case of using NodePort services).

[tabs]
====

Java::
+
--
[source, java]
----
ClientConfig config = new ClientConfig();
config.getNetworkConfig().addAddress("10.96.184.178");
----
--

NodeJS::
+
--
[source, javascript]
----
const { Client } = require('hazelcast-client');

const clientConfig = {
    network: {
        clusterMembers: [
            'hz-hazelcast'
        ]
    }
};
const client = await Client.newHazelcastClient(clientConfig);
----
--

====

=== Run Hazelcast Client application

You can run the client application with the following command.

[tabs]
====

Java::
+
[source, shell script]
----
mvn -f java/pom.xml package
java -jar java/target/*jar-with-dependencies*.jar
----
--

NodeJS::
+
--
[source, javascript]
----
const { Client } = require('hazelcast-client');

const clientConfig = {
    network: {
        clusterMembers: [
            'hz-hazelcast'
        ]
    }
};
const client = await Client.newHazelcastClient(clientConfig);
----
--

====

Application is a web service that uses Hazelcast Client to connect to the Hazelcast cluster.
To check it works correctly, you can execute the following commands:

[source, shell script]
----
$ curl "localhost:8080/put?key=some-key&value=some-value"
{"response":null}

$ curl "localhost:8080/get?key=some-key"
{"response":"some-value"}
----

You can also check the application logs to see:

[source, shell script]
----
Members [3] {
	Member [10.172.2.8]:5701 - 77fb7da6-79bd-4b5b-9c63-2c425a111c06
	Member [10.172.0.4]:5701 - d63bd9f6-7afd-4b9b-88d3-f3b6afb749f9
	Member [10.172.0.5]:5701 - 049fe137-9cfd-4be8-80a3-d1357a31f6f4
}
----
